name: Deploy
on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      RG: ${{ secrets.AZURE_RESOURCE_GROUP }}
      ACR: ${{ secrets.ACR_LOGIN_SERVER }}
      ACR_NAME: ${{ secrets.ACR_NAME }}

      ENV_NAME: ts-env
      QDRANT_APP: ts-qdrant
      API_APP: ts-api
      UI_APP: ts-ui

      API_IMAGE: ${{ secrets.ACR_LOGIN_SERVER }}/api:${{ github.sha }}
      UI_IMAGE:  ${{ secrets.ACR_LOGIN_SERVER }}/ui:${{ github.sha }}

    steps:
      - uses: actions/checkout@v4

      # Login to ACR to push images
      - name: ACR login
        uses: azure/docker-login@v1
        with:
          login-server: ${{ secrets.ACR_LOGIN_SERVER }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      # Debug tree to see where files are
      - name: Debug workspace tree
        run: |
          echo "GITHUB_WORKSPACE=$GITHUB_WORKSPACE"
          pwd
          ls -la
          echo "Dockerfiles found (depth<=4):"
          find . -maxdepth 4 -type f -iname "Dockerfile*"
      - name: Enable Container Apps extension (no subscription registration here)
        run: |
          az extension add --name containerapp --yes || az extension update --name containerapp
          STATE=$(az provider show -n Microsoft.App --query registrationState -o tsv || echo Unknown)
          echo "Microsoft.App provider state: $STATE"
          if [ "$STATE" != "Registered" ]; then
            echo "::warning::Resource provider 'Microsoft.App' is NOT registered on the subscription. Register it once from a user with subscription-level rights: 'az provider register -n Microsoft.App'."
          fi
      # Detect API Dockerfile: prefer Dockerfile.api, fallback to Dockerfile
      - name: Detect API Dockerfile
        id: detect_api
        run: |
          set -e
          ROOT="${GITHUB_WORKSPACE}"
          # prefer Dockerfile.api anywhere in repo
          API_FILE="$(git ls-files | grep -Ei '(^|/)Dockerfile\.api$' | head -n1 || true)"
          if [ -z "$API_FILE" ]; then
            # fallback to plain Dockerfile if you ever rename it
            API_FILE="$(git ls-files | grep -Ei '(^|/)Dockerfile$' | head -n1 || true)"
          fi
          if [ -z "$API_FILE" ]; then
            echo "::error::Could not find Dockerfile.api (or Dockerfile) for API. Is it committed?"
            exit 1
          fi
          API_CTX="$(dirname "$API_FILE")"
          echo "CTX=$GITHUB_WORKSPACE/$API_CTX" >> $GITHUB_OUTPUT
          echo "FILE=$GITHUB_WORKSPACE/$API_FILE" >> $GITHUB_OUTPUT
          echo "API context: $API_CTX"
          echo "API file:    $API_FILE"

      # Detect UI Dockerfile: expect Dockerfile.ui
      - name: Detect UI Dockerfile
        id: detect_ui
        run: |
          set -e
          ROOT="${GITHUB_WORKSPACE}"
          UI_FILE="$(git ls-files | grep -Ei '(^|/)Dockerfile\.ui$' | head -n1 || true)"
          if [ -z "$UI_FILE" ]; then
            echo "::error::Could not find Dockerfile.ui for UI. Is it committed?"
            exit 1
          fi
          UI_CTX="$(dirname "$UI_FILE")"
          echo "CTX=$GITHUB_WORKSPACE/$UI_CTX" >> $GITHUB_OUTPUT
          echo "FILE=$GITHUB_WORKSPACE/$UI_FILE" >> $GITHUB_OUTPUT
          echo "UI context: $UI_CTX"
          echo "UI file:    $UI_FILE"

      # Build & push API image
      - name: Build & push API image
        uses: docker/build-push-action@v5
        with:
          context: ${{ steps.detect_api.outputs.CTX }}
          file:    ${{ steps.detect_api.outputs.FILE }}
          push: true
          tags: ${{ env.API_IMAGE }}
          provenance: false

      # Build & push UI image
      - name: Build & push UI image
        uses: docker/build-push-action@v5
        with:
          context: ${{ steps.detect_ui.outputs.CTX }}
          file:    ${{ steps.detect_ui.outputs.FILE }}
          push: true
          tags: ${{ env.UI_IMAGE }}
          provenance: false

      # Azure login (Service Principal JSON in AZURE_CREDENTIALS)
      - name: Azure login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # Enable Container Apps CLI extension
      - name: Enable Container Apps extension
        run: |
          az extension add --name containerapp --yes || az extension update --name containerapp
          az provider register --namespace Microsoft.App

      # Qdrant (internal ingress)
      - name: Deploy Qdrant (internal)
        run: |
          set -e
          if az containerapp show -n $QDRANT_APP -g $RG >/dev/null 2>&1; then
            az containerapp update -n $QDRANT_APP -g $RG \
              --image qdrant/qdrant:v1.8.4 \
              --min-replicas 1 --max-replicas 1 \
              --cpu 1 --memory 2Gi
          else
            az containerapp create -n $QDRANT_APP -g $RG --environment $ENV_NAME \
              --image qdrant/qdrant:v1.8.4 \
              --target-port 6333 --ingress internal \
              --min-replicas 1 --max-replicas 1 \
              --cpu 1 --memory 2Gi
          fi

      # API (external)
      - name: Deploy API (external)
        run: |
          set -e
          if az containerapp show -n $API_APP -g $RG >/dev/null 2>&1; then
            az containerapp update -n $API_APP -g $RG \
              --image $API_IMAGE \
              --set-env-vars QDRANT_URL=http://$QDRANT_APP:6333 \
                             ENABLE_STRUCTURED_EXTRACT=true \
                             LLM_MODEL_PROVIDER=openai \
                             LLM_MODEL_NAME=gpt-4o-mini \
                             RERANK_CANDIDATES=10 \
                             OPENAI_API_KEY=secretref:OPENAI_KEY \
              --secrets OPENAI_KEY=${{ secrets.OPENAI_KEY }} \
              --min-replicas 0 --max-replicas 2 \
              --cpu 1 --memory 2Gi
          else
            az containerapp create -n $API_APP -g $RG --environment $ENV_NAME \
              --image $API_IMAGE \
              --target-port 8000 --ingress external \
              --registry-server $ACR \
              --set-env-vars QDRANT_URL=http://$QDRANT_APP:6333 \
                             ENABLE_STRUCTURED_EXTRACT=true \
                             LLM_MODEL_PROVIDER=openai \
                             LLM_MODEL_NAME=gpt-4o-mini \
                             RERANK_CANDIDATES=10 \
                             OPENAI_API_KEY=secretref:OPENAI_KEY \
              --secrets OPENAI_KEY=${{ secrets.OPENAI_KEY }} \
              --min-replicas 0 --max-replicas 2 \
              --cpu 1 --memory 2Gi
          fi

      # UI (external) – point to API FQDN
      - name: Deploy UI (external)
        run: |
          set -e
          API_FQDN=$(az containerapp show -n $API_APP -g $RG --query properties.configuration.ingress.fqdn -o tsv)
          if az containerapp show -n $UI_APP -g $RG >/dev/null 2>&1; then
            az containerapp update -n $UI_APP -g $RG \
              --image $UI_IMAGE \
              --set-env-vars API_BASE=https://$API_FQDN \
              --min-replicas 0 --max-replicas 2 \
              --cpu 1 --memory 1Gi
          else
            az containerapp create -n $UI_APP -g $RG --environment $ENV_NAME \
              --image $UI_IMAGE \
              --target-port 8501 --ingress external \
              --registry-server $ACR \
              --set-env-vars API_BASE=https://$API_FQDN \
              --min-replicas 0 --max-replicas 2 \
              --cpu 1 --memory 1Gi
          fi

      # Seed + ingest with simple retry (so the demo is populated)
      - name: Seed sample data
        run: |
          set -e
          for i in {1..5}; do
            if az containerapp exec -n $API_APP -g $RG --command "python -m scripts.seed_sample"; then
              exit 0
            fi
            echo "Retry seed ($i/5) in 10s…"; sleep 10
          done
          echo "::error::Seed failed after 5 attempts"; exit 1

      - name: Ingest all (soft DQ)
        run: |
          set -e
          for i in {1..5}; do
            if az containerapp exec -n $API_APP -g $RG --command "python - <<'PY'\nfrom flows.ingest_all import ingest_all\nprint(ingest_all(dq_fail_on_error=False))\nPY"; then
              exit 0
            fi
            echo "Retry ingest ($i/5) in 10s…"; sleep 10
          done
          echo "::error::Ingest failed after 5 attempts"; exit 1

      # Print live URLs
      - name: Show live URLs
        run: |
          API_FQDN=$(az containerapp show -n $API_APP -g $RG --query properties.configuration.ingress.fqdn -o tsv)
          UI_FQDN=$(az containerapp show -n $UI_APP -g $RG --query properties.configuration.ingress.fqdn -o tsv)
          echo "API: https://$API_FQDN"
          echo "UI:  https://$UI_FQDN"
